/*
 * AngularJS Toaster
 * Version: 1.2.0
 *
 * Copyright 2013-2016 Jiri Kavulak.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * Author: Jiri Kavulak
 * Related to project of John Papa, Hans Fjällemark and Nguy?n Thi?n Hùng (thienhung1989)

!function(t,e){"use strict";angular.module("toaster",[]).constant("toasterConfig",{limit:0,"tap-to-dismiss":!0,"close-button":!1,"close-html":'<button class="toast-close-button" type="button">&times;</button>',"newest-on-top":!0,"time-out":5e3,"icon-classes":{error:"toast-error",info:"toast-info",wait:"toast-wait",success:"toast-success",warning:"toast-warning"},"body-output-type":"","body-template":"toasterBodyTmpl.html","icon-class":"toast-info","position-class":"toast-top-right","title-class":"toast-title","message-class":"toast-message","prevent-duplicates":!1,"mouseover-timer-stop":!0}).service("toaster",["$rootScope","toasterConfig",function(t,e){function o(t){return function(e,o,s,i,a,n,r,c,l){angular.isString(e)?this.pop(t,e,o,s,i,a,n,r,c,l):this.pop(angular.extend(e,{type:t}))}}this.pop=function(e,o,s,i,a,n,r,c,l,u){if(angular.isObject(e)){var d=e;this.toast={type:d.type,title:d.title,body:d.body,timeout:d.timeout,bodyOutputType:d.bodyOutputType,clickHandler:d.clickHandler,showCloseButton:d.showCloseButton,closeHtml:d.closeHtml,uid:d.toastId,onShowCallback:d.onShowCallback,onHideCallback:d.onHideCallback,directiveData:d.directiveData},l=d.toastId,r=d.toasterId}else this.toast={type:e,title:o,body:s,timeout:i,bodyOutputType:a,clickHandler:n,showCloseButton:c,uid:l,onHideCallback:u};t.$emit("toaster-newToast",r,l)},this.clear=function(e,o){t.$emit("toaster-clearToasts",e,o)};for(var s in e["icon-classes"])this[s]=o(s)}]).factory("toasterEventRegistry",["$rootScope",function(t){var e,o=null,s=null,i=[],a=[];return e={setup:function(){o||(o=t.$on("toaster-newToast",function(t,e,o){for(var s=0,a=i.length;a>s;s++)i[s](t,e,o)})),s||(s=t.$on("toaster-clearToasts",function(t,e,o){for(var s=0,i=a.length;i>s;s++)a[s](t,e,o)}))},subscribeToNewToastEvent:function(t){i.push(t)},subscribeToClearToastsEvent:function(t){a.push(t)},unsubscribeToNewToastEvent:function(t){var e=i.indexOf(t);e>=0&&i.splice(e,1),0===i.length&&(o(),o=null)},unsubscribeToClearToastsEvent:function(t){var e=a.indexOf(t);e>=0&&a.splice(e,1),0===a.length&&(s(),s=null)}},{setup:e.setup,subscribeToNewToastEvent:e.subscribeToNewToastEvent,subscribeToClearToastsEvent:e.subscribeToClearToastsEvent,unsubscribeToNewToastEvent:e.unsubscribeToNewToastEvent,unsubscribeToClearToastsEvent:e.unsubscribeToClearToastsEvent}}]).directive("directiveTemplate",["$compile","$injector",function(t,e){return{restrict:"A",scope:{directiveName:"@directiveName",directiveData:"@directiveData"},replace:!0,link:function(o,s,i){o.$watch("directiveName",function(a){if(angular.isUndefined(a)||a.length<=0)throw new Error("A valid directive name must be provided via the toast body argument when using bodyOutputType: directive");var n;try{n=e.get(i.$normalize(a)+"Directive")}catch(r){throw new Error(a+" could not be found. The name should appear as it exists in the markup, not camelCased as it would appear in the directive declaration, e.g. directive-name not directiveName.")}var c=n[0];if(c.scope!==!0&&c.scope)throw new Error("Cannot use a directive with an isolated scope. The scope must be either true or falsy (e.g. false/null/undefined). Occurred for directive "+a+".");if(c.restrict.indexOf("A")<0)throw new Error('Directives must be usable as attributes. Add "A" to the restrict option (or remove the option entirely). Occurred for directive '+a+".");o.directiveData&&(o.directiveData=angular.fromJson(o.directiveData));var l=t("<div "+a+"></div>")(o);s.append(l)})}}}]).directive("toasterContainer",["$parse","$rootScope","$interval","$sce","toasterConfig","toaster","toasterEventRegistry",function(t,e,o,s,i,a,n){return{replace:!0,restrict:"EA",scope:!0,link:function(e,r,c){function l(t,s){t.timeoutPromise=o(function(){e.removeToast(t.id)},s,1)}function u(o,i){if(o.type=v["icon-classes"][o.type],o.type||(o.type=v["icon-class"]),v["prevent-duplicates"]===!0)if(p(i)){if(e.toasters.length>0&&e.toasters[e.toasters.length-1].body===o.body)return}else{var a,n;for(a=0,n=e.toasters.length;n>a;a++)e.toasters[a].uid===i&&(d(a),a--,n=e.toasters.length)}o.id=++f,p(i)||(o.uid=i);var r=v["close-button"];if("boolean"==typeof o.showCloseButton);else if("boolean"==typeof r)o.showCloseButton=r;else if("object"==typeof r){var c=r[o.type];"undefined"!=typeof c&&null!==c&&(o.showCloseButton=c)}else o.showCloseButton=!1;switch(o.showCloseButton&&(o.closeHtml=s.trustAsHtml(o.closeHtml||e.config.closeHtml)),o.bodyOutputType=o.bodyOutputType||v["body-output-type"],o.bodyOutputType){case"trustedHtml":o.html=s.trustAsHtml(o.body);break;case"template":o.bodyTemplate=o.body||v["body-template"];break;case"templateWithData":var l=t(o.body||v["body-template"]),u=l(e);o.bodyTemplate=u.template,o.data=u.data;break;case"directive":o.html=o.body}e.configureTimer(o),v["newest-on-top"]===!0?(e.toasters.unshift(o),v.limit>0&&e.toasters.length>v.limit&&e.toasters.pop()):(e.toasters.push(o),v.limit>0&&e.toasters.length>v.limit&&e.toasters.shift()),angular.isFunction(o.onShowCallback)&&o.onShowCallback()}function d(t){var s=e.toasters[t];s.timeoutPromise&&o.cancel(s.timeoutPromise),e.toasters.splice(t,1),angular.isFunction(s.onHideCallback)&&s.onHideCallback()}function m(t){for(var o=e.toasters.length-1;o>=0;o--)p(t)?d(o):e.toasters[o].uid==t&&d(o)}function p(t){return angular.isUndefined(t)||null===t}var v,f=0;v=angular.extend({},i,e.$eval(c.toasterOptions)),e.config={toasterId:v["toaster-id"],position:v["position-class"],title:v["title-class"],message:v["message-class"],tap:v["tap-to-dismiss"],closeButton:v["close-button"],closeHtml:v["close-html"],animation:v["animation-class"],mouseoverTimer:v["mouseover-timer-stop"]},e.$on("$destroy",function(){n.unsubscribeToNewToastEvent(e._onNewToast),n.unsubscribeToClearToastsEvent(e._onClearToasts)}),e.configureTimer=function(t){var e=angular.isNumber(t.timeout)?t.timeout:v["time-out"];"object"==typeof e&&(e=e[t.type]),e>0&&l(t,e)},e.removeToast=function(t){var o,s;for(o=0,s=e.toasters.length;s>o;o++)if(e.toasters[o].id===t){d(o);break}},e.toasters=[],e._onNewToast=function(t,o,s){(p(e.config.toasterId)&&p(o)||!p(e.config.toasterId)&&!p(o)&&e.config.toasterId==o)&&u(a.toast,s)},e._onClearToasts=function(t,o,s){("*"==o||p(e.config.toasterId)&&p(o)||!p(e.config.toasterId)&&!p(o)&&e.config.toasterId==o)&&m(s)},n.setup(),n.subscribeToNewToastEvent(e._onNewToast),n.subscribeToClearToastsEvent(e._onClearToasts)},controller:["$scope","$element","$attrs",function(t,e,s){t.stopTimer=function(e){t.config.mouseoverTimer===!0&&e.timeoutPromise&&(o.cancel(e.timeoutPromise),e.timeoutPromise=null)},t.restartTimer=function(e){t.config.mouseoverTimer===!0?e.timeoutPromise||t.configureTimer(e):null===e.timeoutPromise&&t.removeToast(e.id)},t.click=function(e,o){if(t.config.tap===!0||e.showCloseButton===!0&&o===!0){var s=!0;e.clickHandler&&(angular.isFunction(e.clickHandler)?s=e.clickHandler(e,o):angular.isFunction(t.$parent.$eval(e.clickHandler))?s=t.$parent.$eval(e.clickHandler)(e,o):console.log("TOAST-NOTE: Your click handler is not inside a parent scope of toaster-container.")),s&&t.removeToast(e.id)}}}],template:'<div id="toast-container" ng-class="[config.position, config.animation]"><div ng-repeat="toaster in toasters" class="toast" ng-class="toaster.type" ng-click="click(toaster)" ng-mouseover="stopTimer(toaster)" ng-mouseout="restartTimer(toaster)"><div ng-if="toaster.showCloseButton" ng-click="click(toaster, true)" ng-bind-html="toaster.closeHtml"></div><div ng-class="config.title">{{toaster.title}}</div><div ng-class="config.message" ng-switch on="toaster.bodyOutputType"><div ng-switch-when="trustedHtml" ng-bind-html="toaster.html"></div><div ng-switch-when="template"><div ng-include="toaster.bodyTemplate"></div></div><div ng-switch-when="templateWithData"><div ng-include="toaster.bodyTemplate"></div></div><div ng-switch-when="directive"><div directive-template directive-name="{{toaster.html}}" directive-data="{{toaster.directiveData}}"></div></div><div ng-switch-default >{{toaster.body}}</div></div></div></div>'}}])}(window,document);

*/

(function () {
    'use strict';

    angular.module('toastr', [])
      .factory('toastr', toastr);

    toastr.$inject = ['$animate', '$injector', '$rootScope', '$sce', 'toastrConfig', '$q'];

    function toastr($animate, $injector, $rootScope, $sce, toastrConfig, $q) {
        var container;
        var index = 0;
        var toasts = [];

        var previousToastMessage = '';
        var openToasts = {};

        var containerDefer = $q.defer();

        var toast = {
            active: active,
            clear: clear,
            error: error,
            info: info,
            remove: remove,
            success: success,
            warning: warning,
            refreshTimer: refreshTimer
        };

        return toast;

        /* Public API */
        function active() {
            return toasts.length;
        }

        function clear(toast) {
            // Bit of a hack, I will remove this soon with a BC
            if (arguments.length === 1 && !toast) { return; }

            if (toast) {
                remove(toast.toastId);
            } else {
                for (var i = 0; i < toasts.length; i++) {
                    remove(toasts[i].toastId);
                }
            }
        }

        function error(message, title, optionsOverride) {
            var type = _getOptions().iconClasses.error;
            return _buildNotification(type, message, title, optionsOverride);
        }

        function info(message, title, optionsOverride) {
            var type = _getOptions().iconClasses.info;
            return _buildNotification(type, message, title, optionsOverride);
        }

        function success(message, title, optionsOverride) {
            var type = _getOptions().iconClasses.success;
            return _buildNotification(type, message, title, optionsOverride);
        }

        function warning(message, title, optionsOverride) {
            var type = _getOptions().iconClasses.warning;
            return _buildNotification(type, message, title, optionsOverride);
        }

        function refreshTimer(toast, newTime) {
            if (toast && toast.isOpened && toasts.indexOf(toast) >= 0) {
                toast.scope.refreshTimer(newTime);
            }
        }

        function remove(toastId, wasClicked) {
            var toast = findToast(toastId);

            if (toast && !toast.deleting) { // Avoid clicking when fading out
                toast.deleting = true;
                toast.isOpened = false;
                $animate.leave(toast.el).then(function () {
                    if (toast.scope.options.onHidden) {
                        toast.scope.options.onHidden(!!wasClicked, toast);
                    }
                    toast.scope.$destroy();
                    var index = toasts.indexOf(toast);
                    delete openToasts[toast.scope.message];
                    toasts.splice(index, 1);
                    var maxOpened = toastrConfig.maxOpened;
                    if (maxOpened && toasts.length >= maxOpened) {
                        toasts[maxOpened - 1].open.resolve();
                    }
                    if (lastToast()) {
                        container.remove();
                        container = null;
                        containerDefer = $q.defer();
                    }
                });
            }

            function findToast(toastId) {
                for (var i = 0; i < toasts.length; i++) {
                    if (toasts[i].toastId === toastId) {
                        return toasts[i];
                    }
                }
            }

            function lastToast() {
                return !toasts.length;
            }
        }

        /* Internal functions */
        function _buildNotification(type, message, title, optionsOverride) {
            if (angular.isObject(title)) {
                optionsOverride = title;
                title = null;
            }

            return _notify({
                iconClass: type,
                message: message,
                optionsOverride: optionsOverride,
                title: title
            });
        }

        function _getOptions() {
            return angular.extend({}, toastrConfig);
        }

        function _createOrGetContainer(options) {
            if (container) { return containerDefer.promise; }

            container = angular.element('<div></div>');
            container.attr('id', options.containerId);
            container.addClass(options.positionClass);
            container.css({ 'pointer-events': 'auto' });

            var target = angular.element(document.querySelector(options.target));

            if (!target || !target.length) {
                throw 'Target for toasts doesn\'t exist';
            }

            $animate.enter(container, target).then(function () {
                containerDefer.resolve();
            });

            return containerDefer.promise;
        }

        function _notify(map) {
            var options = _getOptions();

            if (shouldExit()) { return; }

            var newToast = createToast();

            toasts.push(newToast);

            if (ifMaxOpenedAndAutoDismiss()) {
                var oldToasts = toasts.slice(0, (toasts.length - options.maxOpened));
                for (var i = 0, len = oldToasts.length; i < len; i++) {
                    remove(oldToasts[i].toastId);
                }
            }

            if (maxOpenedNotReached()) {
                newToast.open.resolve();
            }

            newToast.open.promise.then(function () {
                _createOrGetContainer(options).then(function () {
                    newToast.isOpened = true;
                    if (options.newestOnTop) {
                        $animate.enter(newToast.el, container).then(function () {
                            newToast.scope.init();
                        });
                    } else {
                        var sibling = container[0].lastChild ? angular.element(container[0].lastChild) : null;
                        $animate.enter(newToast.el, container, sibling).then(function () {
                            newToast.scope.init();
                        });
                    }
                });
            });

            return newToast;

            function ifMaxOpenedAndAutoDismiss() {
                return options.autoDismiss && options.maxOpened && toasts.length > options.maxOpened;
            }

            function createScope(toast, map, options) {
                if (options.allowHtml) {
                    toast.scope.allowHtml = true;
                    toast.scope.title = $sce.trustAsHtml(map.title);
                    toast.scope.message = $sce.trustAsHtml(map.message);
                } else {
                    toast.scope.title = map.title;
                    toast.scope.message = map.message;
                }

                toast.scope.toastType = toast.iconClass;
                toast.scope.toastId = toast.toastId;
                toast.scope.extraData = options.extraData;

                toast.scope.options = {
                    extendedTimeOut: options.extendedTimeOut,
                    messageClass: options.messageClass,
                    onHidden: options.onHidden,
                    onShown: generateEvent('onShown'),
                    onTap: generateEvent('onTap'),
                    progressBar: options.progressBar,
                    tapToDismiss: options.tapToDismiss,
                    timeOut: options.timeOut,
                    titleClass: options.titleClass,
                    toastClass: options.toastClass
                };

                if (options.closeButton) {
                    toast.scope.options.closeHtml = options.closeHtml;
                }

                function generateEvent(event) {
                    if (options[event]) {
                        return function () {
                            options[event](toast);
                        };
                    }
                }
            }

            function createToast() {
                var newToast = {
                    toastId: index++,
                    isOpened: false,
                    scope: $rootScope.$new(),
                    open: $q.defer()
                };
                newToast.iconClass = map.iconClass;
                if (map.optionsOverride) {
                    angular.extend(options, cleanOptionsOverride(map.optionsOverride));
                    newToast.iconClass = map.optionsOverride.iconClass || newToast.iconClass;
                }

                createScope(newToast, map, options);

                newToast.el = createToastEl(newToast.scope);

                return newToast;

                function cleanOptionsOverride(options) {
                    var badOptions = ['containerId', 'iconClasses', 'maxOpened', 'newestOnTop',
                                      'positionClass', 'preventDuplicates', 'preventOpenDuplicates', 'templates'];
                    for (var i = 0, l = badOptions.length; i < l; i++) {
                        delete options[badOptions[i]];
                    }

                    return options;
                }
            }

            function createToastEl(scope) {
                var angularDomEl = angular.element('<div toast></div>'),
                  $compile = $injector.get('$compile');
                return $compile(angularDomEl)(scope);
            }

            function maxOpenedNotReached() {
                return options.maxOpened && toasts.length <= options.maxOpened || !options.maxOpened;
            }

            function shouldExit() {
                var isDuplicateOfLast = options.preventDuplicates && map.message === previousToastMessage;
                var isDuplicateOpen = options.preventOpenDuplicates && openToasts[map.message];

                if (isDuplicateOfLast || isDuplicateOpen) {
                    return true;
                }

                previousToastMessage = map.message;
                openToasts[map.message] = true;

                return false;
            }
        }
    }
}());

(function () {
    'use strict';

    angular.module('toastr')
      .constant('toastrConfig', {
          allowHtml: false,
          autoDismiss: false,
          closeButton: false,
          closeHtml: '<button>&times;</button>',
          containerId: 'toast-container',
          extendedTimeOut: 1000,
          iconClasses: {
              error: 'toast-error',
              info: 'toast-info',
              success: 'toast-success',
              warning: 'toast-warning'
          },
          maxOpened: 0,
          messageClass: 'toast-message',
          newestOnTop: true,
          onHidden: null,
          onShown: null,
          onTap: null,
          positionClass: 'toast-top-right',
          preventDuplicates: false,
          preventOpenDuplicates: false,
          progressBar: false,
          tapToDismiss: true,
          target: 'body',
          templates: {
              toast: 'directives/toast/toast.html',
              progressbar: 'directives/progressbar/progressbar.html'
          },
          timeOut: 5000,
          titleClass: 'toast-title',
          toastClass: 'toast'
      });
}());

(function () {
    'use strict';

    angular.module('toastr')
      .directive('progressBar', progressBar);

    progressBar.$inject = ['toastrConfig'];

    function progressBar(toastrConfig) {
        return {
            require: '^toast',
            templateUrl: function () {
                return toastrConfig.templates.progressbar;
            },
            link: linkFunction
        };

        function linkFunction(scope, element, attrs, toastCtrl) {
            var intervalId, currentTimeOut, hideTime;

            toastCtrl.progressBar = scope;

            scope.start = function (duration) {
                if (intervalId) {
                    clearInterval(intervalId);
                }

                currentTimeOut = parseFloat(duration);
                hideTime = new Date().getTime() + currentTimeOut;
                intervalId = setInterval(updateProgress, 10);
            };

            scope.stop = function () {
                if (intervalId) {
                    clearInterval(intervalId);
                }
            };

            function updateProgress() {
                var percentage = ((hideTime - (new Date().getTime())) / currentTimeOut) * 100;
                element.css('width', percentage + '%');
            }

            scope.$on('$destroy', function () {
                // Failsafe stop
                clearInterval(intervalId);
            });
        }
    }
}());

(function () {
    'use strict';

    angular.module('toastr')
      .controller('ToastController', ToastController);

    function ToastController() {
        this.progressBar = null;

        this.startProgressBar = function (duration) {
            if (this.progressBar) {
                this.progressBar.start(duration);
            }
        };

        this.stopProgressBar = function () {
            if (this.progressBar) {
                this.progressBar.stop();
            }
        };
    }
}());

(function () {
    'use strict';

    angular.module('toastr')
      .directive('toast', toast);

    toast.$inject = ['$injector', '$interval', 'toastrConfig', 'toastr'];

    function toast($injector, $interval, toastrConfig, toastr) {
        return {
            templateUrl: function () {
                return toastrConfig.templates.toast;
            },
            controller: 'ToastController',
            link: toastLinkFunction
        };

        function toastLinkFunction(scope, element, attrs, toastCtrl) {
            var timeout;

            scope.toastClass = scope.options.toastClass;
            scope.titleClass = scope.options.titleClass;
            scope.messageClass = scope.options.messageClass;
            scope.progressBar = scope.options.progressBar;

            if (wantsCloseButton()) {
                var button = angular.element(scope.options.closeHtml),
                  $compile = $injector.get('$compile');
                button.addClass('toast-close-button');
                button.attr('ng-click', 'close(true, $event)');
                $compile(button)(scope);
                element.children().prepend(button);
            }

            scope.init = function () {
                if (scope.options.timeOut) {
                    timeout = createTimeout(scope.options.timeOut);
                }
                if (scope.options.onShown) {
                    scope.options.onShown();
                }
            };

            element.on('mouseenter', function () {
                hideAndStopProgressBar();
                if (timeout) {
                    $interval.cancel(timeout);
                }
            });

            scope.tapToast = function () {
                if (angular.isFunction(scope.options.onTap)) {
                    scope.options.onTap();
                }
                if (scope.options.tapToDismiss) {
                    scope.close(true);
                }
            };

            scope.close = function (wasClicked, $event) {
                if ($event && angular.isFunction($event.stopPropagation)) {
                    $event.stopPropagation();
                }
                toastr.remove(scope.toastId, wasClicked);
            };

            scope.refreshTimer = function (newTime) {
                if (timeout) {
                    $interval.cancel(timeout);
                    timeout = createTimeout(newTime || scope.options.timeOut);
                }
            };

            element.on('mouseleave', function () {
                if (scope.options.timeOut === 0 && scope.options.extendedTimeOut === 0) { return; }
                scope.$apply(function () {
                    scope.progressBar = scope.options.progressBar;
                });
                timeout = createTimeout(scope.options.extendedTimeOut);
            });

            function createTimeout(time) {
                toastCtrl.startProgressBar(time);
                return $interval(function () {
                    toastCtrl.stopProgressBar();
                    toastr.remove(scope.toastId);
                }, time, 1);
            }

            function hideAndStopProgressBar() {
                scope.progressBar = false;
                toastCtrl.stopProgressBar();
            }

            function wantsCloseButton() {
                return scope.options.closeHtml;
            }
        }
    }
}());